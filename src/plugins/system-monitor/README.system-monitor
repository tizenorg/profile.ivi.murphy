0. System-monitor

Along with system-controller a system-monitor plugin has been
added to Murphy, for monitoring/adjusting usage/allocation of
certain system resources (memory and CPU among others).

1. Monitoring Interface

Two new Murphy Lua objects have been introruced for resource
usage monitoring, CpuWatch and MemWatch. These allow one to
set up an arbitrary number of watches for CPU and memory usage
that trigger events/callbacks when certain configrable conditions
become true. This is the basic mechanism that allows one to detect
significant changes in system resource usage and take corrective
actions at will.

1.1 CPU Monitoring

The CPU monitoring interface allows one to monitor the amount of
time (in precentages) the system spends in various states on the
various CPUs. The full scale of CPUs and CPU states exposed by
the kernel (in /proc/stat) is supported. The available CPUs are
'cpu0' to 'cpuN', one for every of the N CPUs/cores in the system.
Additionally, the virtual CPU 'cpu' represents the sum of all CPUs
/ cores combined.

Although the full range of CPU states exposed by the kernel is
available for monitoring, in the vast majority of cases only subset
of these makes sense in a ruleset. These are shortly described
below, but for a better explanation you are free to consult the
kernel documentation or manual page for proc(5).

  - idle:       time spent in idle state
  - iowait:     time spent waiting for I/O
  - guest:      time spent running guest OSs
  - load:       time the system was 'busy' (user + nice + system + I/O wait)
  - user:       time in user mode (running user-space code)
  - nice:       time spent in user mode with lowered (nice's) priority
  - system:     time spent in system state (running the kernel)
  - irq:        time spent serving interupts
  - softirq:    time spent serving softirqs
  - steal:      time spent running other virtualized OSs
  - guest_nice: time spent running virtualized OSs with lowered priority
  - interrupt:  irq + softirq
  - guest_load: guest + guest_nice

Additionally, the functionality of monitoring CPU usage (or idleness)
of cgroups in the cpuacct hierarchy has been unified into and made
available via CPU watches.

A CPU watch Lua object has the following parameters/members:

  - sample:  what entity to monitor, one of the above
  - cpu:     which CPU the watch should monitor
  - limits:  the set of thresholds to generate events/callbacks for
  - window:  optional measurement estimation period (in milliseconds)
  - alpha:   optional smoothing factor, alternative to specifying a window
  - notify:  callback to call for threshold change events

Of these, sample, cpu, and limits can only be written by passing them
to the constructor. They can always be read. Window/alpha can always be
read and written, and notify can only be written. For cgroup watches,
only load or idle are allowed for sample, and cpu specifies both the
path to the CPU accounting cgroup and the CPU to monitor. It has the
format '/path/to/cgroup#cpu'. '#cpu' is the default and can be omitted.

There are a few additional parameters/members available for use:

  - value:    current estimate of the monitored entity
  - raw:      the last sample collected from the monitored entity
  - current:  currently active threshold label
  - previous: previously active threshold label
  - polling:  sample collection interval (in msecs)

Of these value, raw, current, previous, and polling can only be read,
while update can only be written.

The default sample-collection algorithm uses an exponentially weighted
moving average over the specified window or with the smoothing factor
whichever was specified to calculate an estimate of the monitored entity.
If no window/factor is given, it is set to of 0/1 which in practice
disables the estimator altogether and uses the last collected sample as
the estimate.

If there is really a need for it, the default algorithm can be overridden
by setting the update member to a function. This function will be called
by the monitor to update its estimate. It is passed two arguments, the
object itself and the latest sample. It should return true if the new
estimate results in a change of active threshold, false otherwise.

1.2 CPU Monitoring Example

Here is an example of setting up a CPU monitor that will monitor
how busy the system is:

--
-- get and configure system-monitor to poll once per second
--
sm = m:get_system_monitor()
sm.polling = 1000                                 -- poll once per second

--
-- monitor overall CPU load (load of the virtual combined CPU)
--
sm:CpuWatch({
         cpu    = 'cpu',                          -- virtual 'combined' CPU
         sample = 'load',                         -- monitor 'load'
         limits = {                               -- load threshold limits
             [1] = { label = 'idle'    , limit =  5 },
             [2] = { label = 'low'     , limit = 20 },
             [3] = { label = 'moderate', limit = 40 },
             [4] = { label = 'medium'  , limit = 50 },
             [5] = { label = 'high'    , limit = 80 },
             [6] = { label = 'critical'             }
         },
         window = 15000,                          -- use an EWMA of 15 secs
         notify = function (w, prev, curr)        -- threshold change callback
            print('CPU load change: ' .. prev .. ' -> ' .. curr)
         end
    })


This first sets the system-monitor polling/data collection interval to
1 second (1000 milliseconds), then creates a CPU watch for the virtual
combined 'cpu' and monitor the virtual entity 'load', which if you recall
was the time spent in user + nice + system + I/O wait states. The CPU
watch smoothes the collected samples over a 15 seconds (15000 milli-
seconds) period and has 5 limits specified yielding 6 thresholds to
generate event callbacks about:

   1. idle:        <  5 %
   2. low:       5 - 20 %
   3. moderate: 20 - 40 %
   4. medium:   40 - 50 %
   5. high:     50 - 80 %
   6. critical:    > 80 %

The event callback simply prints out the thresholds the system is
transitioning from and to.

Here is another one that configures the global polling interval to
5 seconds and monitors the idle time of the CPU accounting group
/foo, disabling smoothing and always using the last sample as the
actual value.

--
-- get and configure system-monitor to poll every 5 seconds
--
sm = m:get_system_monitor()
sm.polling = 5000

--
-- monitor idleness of '/foo' cgroup
--
sm:CpuWatch({
         cpu    = '/foo',                         -- monitor /foo cgroup
         sample = 'idle',                         -- monitor idleness
         limits = {                               -- load threshold limits
             [1] = { label = 'none'    , limit =  5 },
             [2] = { label = 'minimal' , limit = 20 },
             [3] = { label = 'medium'  , limit = 50 },
             [4] = { label = 'high'    , limit = 80 },
             [5] = { label = 'full'                 }
         },
         window = 0,                              -- disable EWMA
         notify = function (w, prev, curr)        -- threshold change callback
            print('/foo CPU idle change: ' .. prev .. ' -> ' .. curr ..
                  '(value=' .. w.value .. ', sample=' .. w.raw .. ')')
         end
    })

1.3 Monitoring Memory Usage

The memory usage monitoring interface allows one to monitor how
much memory is used or free for various things by the system.
Currently the following measures can be monitored:

  - MemFree:   amount of memory free
  - SwapFree:  amount of swap space free
  - Dirty:     amount of memory waiting to be written back to storage
  - Writeback: amount of memory actively being written back to storage

Note that support for monitoring memory usage of a particular cgroup
via memory watches as not been fully implemented yet.

A memory watch Lua object has the following parameters/members:

  - sample:  what entitiy to monitor, one of the above
  - limits:  the set of thresholds to generate events/callbacks for
  - window:  optional measurement estimation period (in millisecsonds)
  - alpha:   optional smoothing factor, alternative to specifying a window
  - notify:  callback to call for threshold change events

Of these sample and limits can only be written by passing them to the
constructor. They can always be read. Window/alpha can always be read
and written, and notify can only be written. Limits can be specified
in bytes, kilobytes ('k' suffix), megabytes ('M' suffix), or in
gigabytes ('G' suffix).

There are a few additional parameters/members available for use:

  - value:    current estimate of the monitored entity
  - raw:      the last sample collected from the monitored entity
  - current:  currently active threshold label
  - previous: previously active threshold label
  - polling:  sample collection interval (in msecs)

Of these value, raw, current, previous, and polling can only be read,
while update can only be written.

The default sample-collection algorithm uses an exponentially weighted
moving average over the specified window or with the smoothing factor
whichever was specified to calculate an estimate of the monitored entity.
If no window/factor is given, it is set to of 0/1 which in practice
disables the estimator altogether and uses the last collected sample as
the estimate.

If there is really a need for it, the default algorithm can be overridden
by setting the update member to a function. This function will be called
by the monitor to update its estimate. It is passed two arguments, the
object itself and the latest sample. It should return true if the new
estimate results in a change of active threshold, false otherwise.

1.4 Memory Usage Monitoring Example

Here is a simple example of setting up memory monitors for
the writeback queue and the amount of dirty memory. They are
quite analoguous to setting up CPU watches.

--
-- get and configure system-monitor to poll every 5 seconds
--
sm = m:get_system_monitor()
sm.polling = 5000

--
-- monitor length of the writeback queue
--
sm:MemWatch({
         sample = 'Writeback',
         limits = {                               -- pressure thresholds
             [1] = { label = 'none'    , limit = 1024   },
             [2] = { label = 'light'   , limit = '128k' },
             [3] = { label = 'medium'  , limit = '512k' },
             [4] = { label = 'high'    , limit = '2M'   },
             [5] = { label = 'critical', limit = '16M'  }
         },
         window = 0,                              -- don't average/integrate
         notify = function (w, prev, curr)        -- threshold change callback
            print(w.sample .. ' change: ' .. prev .. ' -> ' .. curr)
         end
     })

--
-- monitor the amount of dirty memory
--
sm:MemWatch({
         sample = 'Dirty',
         limits = {                               -- pressure thresholds
             [1] = { label = 'none'    , limit =  1024 },
             [2] = { label = 'low'     , limit =  8192 },
             [3] = { label = 'medium'  , limit =  '1M' },
             [4] = { label = 'high'    , limit =  '4M' },
             [5] = { label = 'critical', limit = '16M' }
         },
         window = 10000,                           -- use an EWMA of 10 secs
         notify = function (w, prev, curr)         -- threshold change callback
            print(w.sample .. ' change: ' .. prev .. ' -> ' .. curr)
         end
     })


2. Control Group Interface

The control group interface allows one to create, configure (write) and
examine (read) control groups of various types. Creating and configuring
control groups (write access) requires the daemon to have root priviledges,
or more precisely it requires the daemon to be executed with effective
user id 0. If run as a non-priviledged user, the daemon will still have
read-only access to most control groups.

Currently system-monitor supports memory, cpuacct, cpu, and freezer type
of control groups. One can create or open a cgroup using the CGroupOpen
method of the top-level Murphy object. Members of the resulting object
correspond to (supported) filesystem entries of the related control
group. Dereferencing a member will read the value of the filesystem
entry and writing to a member will write to the filesystem entry. Hence,
changing the configuration of a control group can be accomplisehd by
setting the appropriate members of the corresponding object. The control
group object also offers the set_param method to set the given control
group parameter to a given value. This is equivalent to assigning the
given value to the object member with the given name.

Moving a task to a control group can be accomplished by assigning the
task id to the Tasks member of the group object, or alternatively by
calling the add_task method of the group object with the task id as an
argument. Similarly, moving a process (and all its threads) to a control
group can be accomplished by assigning the process id to the Processes
member of the group object or alternatively by calling the add_process
method of the group object with the process id as an argument.

Currently only a subset of the filesystem entries of control groups have
been made available via this object interface. Here is a short summary
for the available entries for the currently supported group types.

memory controller:
    - Limit:           (rw) memory.limit_in_bytes
    - SoftLimit:       (rw) memory.soft_limit_in_bytes
    - Usage:           (ro) memory.usage_in_bytes
    - MaxUsage:        (ro) memory.max_usage_in_bytes
    - MemSwapLimit:    (rw) memory.memsw.limit_in_bytes
    - MemSwapUsage:    (ro) memory.memsw.usage_in_bytes
    - MemSwapMaxUsage: (ro) memory.memsw.max_usage_in_bytes
    - Swappiness:      (rw) memory.swappiness
    - Stat:            (ro) memory.stat
    - Tasks:           (rw) tasks
    - Processes:       (rw) cgroup.procs

cpuacct controller:
    - Usage:           (ro) cpuacct.usage_per_cpu
    - Stat:            (ro) cpuacct.stat
    - Tasks:           (rw) tasks
    - Processes:       (rw) cgroup.procs

cpu controller:
    - Shares:          (rw) cpu.shares
    - CFSPeriod:       (rw) cpu.cfs_period_us
    - CFSQuota:        (rw) cpu.cfs_quota_us
    - RTPeriod:        (rw) cpu.rt_period_us
    - RTRuntime:       (rw) cpu.rt_runtime_us
    - Tasks:           (rw) tasks
    - Processes:       (rw) cgroup.procs

freezer controller:
    - State:           (rw) freezer.state
    - Tasks:           (rw) tasks
    - Processes:       (rw) cgroup.procs

2.1 Control Group Example

Here is simple example of opening the top-level cpuacct control group
in read-only mode and reading out the per-cpu usage counts.

--
-- get top-level Murphy object
--
m = murphy.get()

--
-- open the top cpu accounting group
--
cg = m:CGroupOpen({ type = 'cpuacct',
                    name = '/',
                    mode = 'readonly' })

--
-- read and dump usage and status
--
print('CPU usage per cpu: ')
for i, v in ipairs(cg.Usage) do
    print('  CPU #' .. i .. ': ' .. v)
end

print('CPU usage statistics: ')
for k, v in pairs(cg.Stat) do
    print('  ' .. k .. ': ' .. v)
end


Here is simple example of opening the top-level memory control group
in read-only mode and reading out the uasage and statistics.

--
-- get top-level Murphy object
--
m = murphy.get()

--
-- open the top memory control group
--
mg = m:CGroupOpen({ type = 'memory',
                    name = '/',
                    mode = 'readonly' })

--
-- dump usage and detailed status
--
print('Memory Usage  : ' .. mg.Usage)
print('Mem+Swap Usage: ' .. mg.MemSwapUsage)

print('Memory Detailed Status:')
for k, v in pairs(mg.Stat) do
    print('  ' .. k .. ': ' .. v)
end


Here is a simple example of creating a memory control group with
a certain configuration and moving a given process to it.

--
-- get top-level Murphy object
--
m = murphy.get()

--
-- open the foo memory control group (create if it does not exist)
--
mg = m:CGroupOpen({ type = 'memory',
                    name = 'foo',
                    mode = 'create,readwrite',
                    MemSwapLimit = 200 * 1024 * 1024,
                    Limit        = 100 * 1024 * 1024,
})

mg:add_process(22977)
